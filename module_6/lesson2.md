# Урок 2. Работа с БД из Python

        Текст:

- Генерируем датафрейм, записываем в БД при помощи df.to_sql
- Особенности работы to_sql, рассказать как у меня упал прод из-за неправильного использования to_sql
- Читаем датафрейм при помощи read_sql

## Python + SQLite

Python имеет встроенную поддержку SQLite базы данных, для этого вам не надо ничего дополнительно устанавливать, достаточно в скрипте указать импорт стандартной библиотеки

Так же импортируем pandas, поскольку именно из него мы будем делать запросы:

```python
import sqlite3
import pandas as pd
```

Создадим 5 таблиц из прошлого урока:

- student - информация об учениках
- class - информация о классах учеников
- teacher - информация об учителях
- subject - информация о предметах
- teacher_to_subject - таблица для соединения teacher и subject

Для начала давайте создадим базу данных:

```python
sql = sqlite3.connect('data/school.db')
```

Как аргумент в функцию `connect` мы передаем путь до файла. Функция возвращает соединение с базой данных, которое дальше мы можем использовать, чтобы работать с БД.

Создадим датафрейм для первой таблицы:

```python
names = [
    'Авдеев Антон Антонинович',
    'Сазонова Неолина Богдановна',
    'Капустина Винетта Созоновна',
    'Носкова Алла Ростиславовна',
    'Марков Оскар Викторович',
    'Тетерин Вениамин Антонович'
]

class_ids = [1, 1, 1, 2, 2, 2]

birth_dates = [
    '31.05.2008',
    '30.04.2008',
    '29.03.2008',
    '28.06.2006',
    '27.07.2006',
    '26.08.2006'
]

student_df = pd.DataFrame({'name': names, 'class_id': class_ids, 'birth_date': birth_dates})
```

Датафрейм пока что хранится только в переменной. Давайте запишем его как таблицу в базу данных. Это можно сделать при помощи функции `to_sql()`:

```python
student_df.to_sql('student', sql, index_label="id", if_exists='replace')
```

Первый аргумент функции - название таблицы, в которую мы хотим сохранить датафрейм (`student` в нашем случае).

Второй аргумент - соединение с базой данных, которое `pandas` будет использовать, чтобы записать информацию в нужную БД.

`index_label` отвечает за то, как назвать в базе столбец с индексом датафрейма. Сейчас в индексе хранятся номера учеников, поэтому можем назвать `id`.

Параметр `if_exists` отвечает за то, как поступить, если такая таблица уже существует в БД (например, при повторном запуске этого кода). Возможные варианты:

- replace - заменить все существующие значения в таблице на те, которые передались сейчас
- append - добавить данные в конец таблицы
- fail - возникнет исключение ValueError

Итак, мы записали в базу данных таблицу с данными. На практике вам редко придется делать этот шаг, так как данные, скорее всего, уже будут собраны. Зато придется постоянно читать данные, давайте же прочитаем данные, которые только что записали. Для этого нужно написать SQL-запрос и передать его `pandas`, который отдаст его в СУБД, а ответ превратит в датафрейм. Для этого есть функция `pd.read_sql()`:

```python
pd.read_sql('SELECT * FROM student', sql)
```

Если код выполнился без ошибок, то он должен был вывести таблицу с учениками. Обратите внимание, что колонка `id` теперь не в индексе.

Теперь давайте создадим вторую таблицу с классами и запишем ее в БД:

```python
class_names = [
    '1 "Д"',
    '7 "А"',
    '9 "Б"',
    '11 "В"'
]
class_df = pd.DataFrame({'name': class_names})
class_df.to_sql('class', sql, index_label='id', if_exists='replace')
```

Теперь давайте получим общую таблицу, соединив две таблицы при помощи SQL-запроса:

```python
pd.read_sql(
        '''
        SELECT 
        (student.name, student.birth_date, class.name)
        FROM student
        JOIN class ON student.class_id=class.student_id
        '''
)
```

Используя SQL можно выгружать данные в нужном формате и более глубоко анализировать при помощи `pandas`.
