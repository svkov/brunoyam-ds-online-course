# Урок 2. Библиотека numpy

## Зачем нужна библиотека numpy

Как уже говорилось ранее, `numpy` позволяет эффективно работать с векторами, матрицами и массивами любой размерности, а также позволяет решать некоторые математические задачи, связанные с векторами и матрицами.

Если вам понадобится посчитать скалярное произведение векторов, произведение матриц или решить систему линейных уравнений, то для решения таких задач определенно стоит использовать `numpy`.

Установить `numpy` можно двумя способами - с помощью `conda` или `pip` (выбирайте любой способ):

`conda install numpy`

`pip install numpy`

Давайте разбираться как работать с этой библиотекой.

## Базовые операции

### Создаем массивы

Для того, чтобы работать с `numpy`, для начала необходимо импортировать библиотеку:

```python3
import numpy as np
```

Если после запуска вылезла ошибка, значит библиотека не установлена.

Теперь мы можем обращаться к библиотеке через имя `np`. Сокращение `np` является общепринятым и стоит использовать именно его (а оригинальное `numpy` считают слишком длинным и поэтому сокращают).

Далее мы можем создать массив:

```python3
# Создадим обычный список
test_list = [1, 2, 3]

# Превратим его в массив numpy
array = np.array(test_list)
```

У массива есть некоторые свойства. Например, мы можем узнать его длину (количество элементов внутри) при помощи функции `len`, как и для обычного списка. А также можно узнать его размерность при помощи поля `shape`. Обычно `shape` используют для того, чтобы определить размерность матрицы, но можно использовать и здесь.

```python3
len(array) # 3
array.shape # (3,)
```

Массив можно считать вектором. Поэтому можно, например сложить два вектора, или умножить их на число:

```python3
# Создадим два массива
a = np.array([20, 30, 40, 50])
b = np.array([1, 2, 3, 4])

# Сложение векторов
a + b # [21, 32, 43, 54]

# Умножение на число
2 * a # [40, 60, 80, 100]

# Скалярное произведение
a @ b

# Еще один способ сделать скалярное произведение
a.dot(b)

# Длина вектора a
np.linalg.norm(a)
```

Вернемся к другим способам создать массив. Если нам нужно получить последовательность из чисел от 0 до `n`, то стоит использовать функцию `np.arange`:

```python3
np.arange(5) # array([0, 1, 2, 3, 4])
```

По сути, это аналог `range` (который используем когда пишем цикл `for`), только быстрый и сразу возвращает массив `numpy` (если пишите обычный цикл, то как обычно используйте `range`, тут ничего не меняется).

Еще один способ создать массив - указать начало и конец отрезка и количество точек, на которые этот отрезок будет разбит.  Это можно сделать при помощи функции `np.linspace`. Например, если мы хотим сгенерировать числа от 0 до 10 с шагом 0.5, то лучше всего будет использовать эту функцию.

```python3
np.linspace(0, 10, 21) # [0, 0.5, 1, ..., 9.5, 10]
```

### Матрицы

Создать матрицу не сложнее чем создать вектор. Как и говорилось ранее, матрица - набор векторов:

```python3
matrix = [
  [1, 2, 3],
  [4, 5, 6]
]
np_matrix = np.array(matrix)

# Выведем матрицу
print(np_matrix)
# [[1 2 3]
# [4 5 6]]

# Посмотрим на размерность
print(np_matrix.shape)
# (2, 3)
```

Матрицы можно также складывать и умножать на число, как и векторы. Также матрицы можно умножать между собой. Основные операции над матрицами:

```python3
# a, b - матрицы

a + b # сложение
2 * a # умножение на число
a @ b # умножение матриц (помним про размерность!)
a.dot(b) # тоже умножение, просто другая запись
a * b # поэлементное произведение
a.T # транспонирование
```

Операций довольно много, поэтому возвращайтесь на этот шаг по мере необходимости.

А теперь давайте посмотрим на некоторые матрицы, которые нам нужно создавать довольно часто.

```python3

# Создаем матрицу из нулей
# Обратите внимание, что в качестве аргумента используем кортеж (два раза ставим скобки)

np.zeros((3, 3))

# Результат:
array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])


# Создаем матрицу из единиц
np.ones((3, 3))

# Результат:
array([[1., 1., 1.],
       [1., 1., 1.],
       [1., 1., 1.]])

# Создаем единичную матрицу
np.eye(3)

# Результат:
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
```

Также для массивов доступны операции суммы и поиска минимума/максимума:

```python3
a = np.array([[0, 1], [0, 5]])
a.sum() # Сумма по всему массиву 6
a.sum(axis=0) # Сумма по столбцам [0, 6]
a.sum(axis=1) # Сумма по строкам [1, 5]

a.min() # Минимум по всему массиву 0
a.max() # Максимум по всему массиву 6
```

У функций `min` и `max` также есть параметр axis, который работает точно также как и в `sum`.

## Индексация по массивам

Часто нам приходится из всего массива данных выбирать какие-то конкретные элементы. Например, мы можем захотеть взять из матрицы только конкретную строку или столбец. Все это можно сделать при помощи методов индексации.

```python3

matrix = [
  [1, 2, 3],
  [4, 5, 6]
]
a = np.array(matrix)

a[0] # 0 строка - [1, 2, 3]
a[:, 0] # 0 колонка - [1, 4]
a[:, 0:2] # колонки с 0 по 1 (2 не включается)
# Результат
[[1, 2],
 [4, 5]]

a[0, ::-1] # 0 строка в обратном порядке [3, 2, 1]
a[0, ::2] # элементы 0 строки через одного [1, 3]
a[0, 1::2] # элементы через одного в другом порядке [1, 3]
```

Общая формула выглядит так:

`a[start:stop:step]`

Мы выбираем элементы от `start` до `stop`, шагая с шагом `step`. Это похоже на то, как мы работаем со списками в Python.

Когда добавляются колонки, то по ним мы точно также можем индексироваться:

`a[:, start:stop:step]`

Двоеточие в начале означает, что мы хотим оставить все строки. Можно написать условие, в котором будет одновременно выбирать и по строкам и по колонкам

`a[start1:end1:step1, start2:end2:step2]`

Обратите внимание, что результат индексации не изменяет исходный массив, поэтому если вы хотите дальше использовать измененный массив, то нужно сохранить это значение в новую переменную:

```python3
a[:2, :2]
print(a) # Выведется старый массив, так как никуда не сохранили результат
[[1, 2, 3],
 [4, 5, 6]]


# Сохраним результат в новую переменную
b = a[:2, :2]
print(b)
[[1, 2],
 [4, 5]]
```

## Фильтрация

Иногда нам бывает нужно найти в массиве все значения меньше 3, например. В таких случаях мы можем использовать фильтрацию.

```python3
# Создадим массив
b = np.arange(4) # array([0, 1, 2, 3])

# Выберем элементы меньше 3 и положим их в новый массив
c = b[b < 3] # [0, 1, 2]
```

Обратите внимание, что результат кладем в новую переменную по той же причине как и выше. Если этого не сделать, то фильтрация не сохранится.

Фильтр может состоять из нескольких условий. Такие фильтры называют сложными. Условия могут разделяться операциями И (&) и ИЛИ (|), а также к ним может применяться условие НЕ (~).

```python3
# Четные числа меньше 10
b[
  (b < 10) & (b % 2 == 0)
]

# Положительные числа или -10
b[
  (b > 0) | (b == -10)
]

# Сгененируем еще один массив
a = np.linspace(0, 100, 101)

# И найдем элементы в b, которых нет в a
# Обратите внимание, что стоит знак НЕ ~
b[
  ~np.isin(b, a)
]
```

## Про точность вычислений

Давайте посчитаем несложный пример $0.1 - (0.3 - 0.2)$. Правильный ответ, конечно же, 0.

А теперь давайте посчитаем этот же пример при помощи python

```python
print(0.1 - (0.3 - 0.2)) # 2.7755575615628914e-17
```

Число, которое получилось, очень близко к нулю, но все же не ноль. Почему так получилось? Чтобы ответить на этот вопрос, надо посмотреть как компьютер хранит нецелые числа. Для начала давайте вспомним как хранятся целые числа.

### Как хранятся целые числа

Как мы знаем, компьютер умеет хранить только нули и единицы, поэтому числа представляются при помощи двоичной системы счисления. Например, число 5 можно записать так: $101$, а число 125 вот так: $1111101$. В реальности на каждое число заранее "бронируется" фиксированное количество бит. Например, для типа int в языке C выделяется 16 бит на одно число. Один бит используется чтобы хранить знак (1 - отрицательные, 0 - положительные числа), а остальные 15 бит, чтобы хранить само число. Итак, если мы хотим сохранить то же число 125, то в память оно запишется так (для удобства разделим нули пробелами, первый 0 отвечает за знак): $0\ 000\ 0000\ 0111\ 1101$. Также, получается, максимальное значение, которое мы можем сохранить - это 32767.

В Python реализована длинная арифметика, поэтому мы можем хранить числа любого размера и не переживать, что выйдем за границы типа данных.

### Как хранятся дробные числа

Начать стоит с того, что практически любое дробное число можно представить как частное двух целых чисел (кроме иррациональных чисел, но для них тоже есть формулы). Поэтому давайте считать, что дробная часть числа сохраняется в ходе деления двух целых чисел.

Чтобы сохранить дробное число, нам нужно отдельно сохранить целую и дробную часть числа. Обычно на числа с плавающей точкой выделяется 64 бита (8 байт). [Существует стандарт](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) по которому на знак выделяется 1 бит, на целую часть числа 11 бит и на мантиссу 52 бита. Это позволяет хранить около 16 знаков после запятой. Однако если мы захотим сохранить число, которое в двоичной системе счисления будет иметь бесконечный период (например, 1/10), то мы не сможем точно записать это значение и в десятичной системе.

В двоичной системе 0.1 представляется как $0.0001100110011001100110011001100110011001100110011...$, поэтому на самом деле когда мы записываем это значение в переменную, то она сохраняет гораздо больше значений:

```python
0.1000000000000000055511151231257827021181583404541015625
```

Но так как для большинства из нас эти цифры не имеют значений, результат округляется до привычных 0.1 при выводе значения.

Если же мы вернемся к примеру из начала раздела, то увидим, что внутри каждого из чисел есть небольшая ошибка округления, и поэтому в итоге получается не 0, а число, очень близкое к нему. Округления здесь срабатывает неправильно и мы можем видеть вот такие артефакты.

```python
print(0.1 - (0.3 - 0.2)) # 2.7755575615628914e-17
```

Важно понимать, что это не баг питона и тем более не ваша ошибка, если какие-то вычисления дают сбой в 16 знаке после запятой. Так работают почти все языки программирования и так выглядит стандарт для современных процессоров.

Если вам нужно очень точно (с точностью больше 16 знаков) считать какие-то значения (например, деньги в банковских операциях), то можно использовать библиотеку [Decimal](https://docs.python.org/3/whatsnew/2.4.html#pep-327-decimal-data-type).
