# Урок 3. Библиотека pandas

Текст: ([https://habr.com/ru/company/ruvds/blog/494720/](https://habr.com/ru/company/ruvds/blog/494720/))

- Зачем нужна библиотека pandas
- Объект Series, индекс
- Объект DataFrame, основные операции, понятие axis

## Библиотека pandas

Библиотека `pandas` позволяет удобно работать с табличными данными. Во многих задачах `pandas` позволяет заменить Excel, предоставляя возможность легко фильтровать, сортировать и агрегировать данные.

Также `pandas` позволяет читать файлы с табличными данными и записывать таблицы в файлы в разных форматах. Самый простой формат файлов, с которым мы будем работать - CSV (comma separated values). По сути, это обычный текстовый файл, в котором значения разделены разделителем (обычно это точка или точка с запятой), а перенос на новую строку означает начало новой строки.

Установить `pandas` можно при помощи `conda` и `pip`:

`conda install pandas`

`pip install pandas`

## Поработаем с данными

Для начала давайте импортируем библиотеку:

```python3
import pandas as pd
```

Как и в случае с `numpy`, в `pandas` есть общепринятое сокращение - `pd`.

### Series

Самая простая структура в `pandas` - `Series`. По сути, серия - столбец в таблице (ну или массив/вектор).

```python3
series = pd.Series([1, 2, 3])
print(series)

# Выведет:
0    1
1    2
2    3
dtype: int64
```

Серия также хранит индекс (левый столбец). Индекс сопоставляет каждому значению серии какое-то число. Также индекс может быть, например, датой, и тогда мы сможем понять в какой день проводилось измерение.

```python3
series.index # RangeIndex(start=0, stop=3, step=1)

series.values # array([1, 2, 3])
```

Также индекс может быть строкой и его можно указать при создании серии:

```python3

legs_counter = pd.Series([4, 4, 8], index=["cat", "dog", "spider"])
print(legs_counter)

# Выведет:
cat       4
dog       4
spider    8
dtype: int64
```

По series можно индексирования при помощи loc и iloc

- loc - если хотим взять по индексу
- iloc - если хотим взять по порядковому номеру

```python3
legs_counter.iloc[2] # 8
```

```python3
legs_counter.loc["dog"] # 4
```

### DataFrame

Датафрейм - основная структура `pandas` и она позволяет работать с таблицами. Каждый столбец таблицы является серией, а также есть "главная" колонка - индекс - по которой можно легко искать нужные значения:

```python3
ages = [25, 35, 45]
heights = [170, 180, 190]
names = ["Alex", "Polina", "Misha"]
data = {'age': ages, 'height': heights, 'name': names}
df = pd.DataFrame(data)
print(df)

# Выведет:
    age height  name
0   25  170     Alex
1   35  180     Polina
2   45  190     Misha
```

Поработаем с датафреймом:

```python3
df['age'] # Получился Series
0    25
1    35
2    45
Name: age, dtype: int64


df[['age', 'height']] #Получился DataFrame
    age height
0   25  170
1   35  180
2   45  190

df[['age']] # Получился DataFrame
    age
0   25
1   35
2   45

# Можно добавить новую колонку
df['height/age'] = df['height'] / df['age']
age height  name    height/age
0   25  170 Alex    6.800000
1   35  180 Polina  5.142857
2   45  190 Misha   4.222222

# Можем посчитать суммы/минимумы/максимумы/средние значения
df["age"].sum()
df["age"].min()
df["age"].max()
df["age"].mean()
```

Датафреймы можно фильтровать. Но нужно быть внимательным, ведь сам датафрейм не изменится из-за фильтрации, поэтому нужно складывать результат в новую переменную, если захотим его использовать в дальнейшем.

```python3
df[df['age'] == 25] # Обратите внимание, что сам датафрейм не изменился

    age height  name    height/age
0   25  170     Alex    6.8


df[(df['age'] > 35) & (df['height'] > 170)]

    age height  name    height/age
2   45  190     Misha   4.222222
```

Если нужно поменять какое-то значение, можно использовать .loc

```python3
df.loc[df['age'] == 25, 'age'] = 20

# Проверим, что датафрейм изменился
df[df['height/age'] > 5]
    age height  name    height/age
0   20  170     Alex    6.800000
1   35  180     Polina  5.142857
```

При помощи `apply` мы можем создавать новые колонки из уже имеющихся. Например, если мы хотим поделить людей на "низких" и "высоких" по какому-то порогу, то нужно сделать функцию, которая на вход будет принимать рост, а на выходе скажет высокий человек или низкий. Далее эту функцию нужно передать в `apply`.

```python3
df["height_category"] = df["height"].apply(lambda x: "высокий" if x > 175 else "низкий")

    age height  name    height/age  height_category
0   20  170 Alex    6.800000    низкий
1   35  180 Polina  5.142857    высокий
2   45  190 Misha   4.222222    высокий
```

## Работаем с пропусками

```python3

```

```python3

```

```python3

```

```python3

```

## Работаем с данными

Давайте прочитаем файл с погодой `weather.csv`

```python3
df = pd.read_csv('data/weather.csv`)
```

## Группировка и агрегация данных
