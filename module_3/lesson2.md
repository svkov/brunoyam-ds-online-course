# Коллекции

Коллекции позволяют хранить и удобно работать сразу с большим количеством данных. Если необходимо сохранить 100 одинаковых по смыслу чисел, лучше не делать 100 переменных, а сохранить все в правильную коллекцию.

## Списки

Самая простая коллекция - список (list). Это также встроенный тип в Python.

Список - набор объектов, объединенных логически.

```python
list_example = [1, 2, 3]

len(list_example) # 3 - длина списка

list_example.append(-10) # добавили -10
# [1, 2, 3, -10]

list_example = sorted(list_example) # отсортировали список и обновили его значение
# если не присвоить новое значение, список не изменится
# [-10, 1, 2, 3]

list_example[0] # -10 выбрали первый элемент

list_example[-1] # выбрали последний элемент

list_example[1:3] # [1, 2] выбрали подсписок, 3 не включается
```

Давайте представим, что нам нужно сохранить наблюдения с метеостанции:

```python
observations = [-10, 3, -7, 0, -4, 5, -2, 0]
```

Как вывести все значение больше 0? Использовать цикл! for умеет ходить по спискам. На каждом шаге цикла переменная будет принимать новое значение цикла:

```python
for obs in observations:
    if obs > 0:
        print(obs)
```

Второй способ - использовать range:

```python
for i in range(0, len(observations)): # Идем по всем индексам списка
    if observations[i] > 0: # Проверяем каждый i-ый объект
        print(observations[i])
```

Эти способы эквивалентны в данной задаче. Конечно, приятнее использовать первый способ - он получается короче и проще, но для некоторых задач его будет недостаточно.

Решим такую задачу - найти разницу между всеми соседними измерениями.

Здесь придется идти по всему массиву данных и считать разницу между двумя сосденими элементами, обращаясь к ним по индексу. Разницу можно посчитать так: `observations[i] - observations[i - 1]`, однако нужно помнить, что на нулевом шаге мы выйдем за границы массива (нужно начать итерироваться с 1):

```python
diff_observations = []
for i in range(1, len(observations)):
    diff = observations[i] - observations[i - 1]
    diff_observations.append(diff)
```

В некоторых задачах нам хочется иметь доступ сразу и к номеру итерации и к значению списка. Добиться этого можно при помощи `enumerate`:

```python
for i, val in enumerate(observations):
    print(i, val)

# 0 -10
# 1 3
# 2 -7
# 3 0
# 4 -4
# 5 5
# 6 -2
# 7 0
```

## Кортежи

В Python у списка есть брат-близнец - кортеж. Кортеж - это неизменяемый список. Неизменяемый - значит, что создав его единожды, мы больше не можем поменять его значения.

```python
t = (1, 2, 3) # создаем кортеж
t[0] = 3 # ошибка, нельзя изменять элементы кортежа
```

Для чего нужен кортеж? Он позволяет хранить информацию в структурированном виде. Например, можно хранить таблицы в список из кортежей:

```python
table = [
    ("Alice", 25, 50),
    ("Bob", 27, 80),
    ("Charlie", 30, 90)
]
```

Почему здесь используется именно кортеж, а не список? Потому что значения кортежа нельзя изменить. Значение навсегда связано с его номером в кортеже. Часто выгрузки из баз данных приходят именно в таком виде.

Еще одно применение кортежа - распаковка:

```python
person = ("Alice", 25, 50)
name, age, weight = person
```

Ну и забавное следствие из этого - возможность поменять местами значения двух переменных в одну строку:

```python
a = 1
b = 3
a, b = b, a
# b = 1, a = 3
```

Если нужно сконвертировать кортеж к списку, то это делается при помощи функции `tuple`:

```python
l = [1, 2, 3]
tuple(l) # (1, 2, 3)

# и наоборот

t = (1, 2, 3)
list(t) # [1, 2, 3]
```

Имейте ввиду, что при выполнении этой операции, произойдет копирование данных. поэтому если вы захотите так добавить элемент к кортежу (сконвертировать в список, добавить элемент и сконвертировать в кортеж), то это будет неоптимально.

Вообще, если вам нужно менять кортеж, то не используйте его, а лучше используйте список.

## Словари

Когда нам нужно соотносить два типа значений между собой, то мы используем словарь.

Например, сохраним страны и их столицы:

```python
capital_by_country = {
    'Россия': 'Москва',
    'США': 'Вашингтон',
    'Китай': 'Пекин',
}

# Столица России
capital_by_country['Россия'] # Москва

# Добавим новое значение
capital_by_country['Казахстан'] = 'Астана'

# Обновим значение
capital_by_country['Казахстан'] = 'Нур-Султан'

# Проверим, входит ли значение в словарь
'Германия' in capital_by_country # False

# Если мы понимаем, что какого-то ключа может не быть, может указать значение по умолчанию
capital_by_country.get('Германия', default='unknown') # unknown
```

Главный плюс словарей в том, что они позволяют очень быстро искать значения внутри себя. Для того, чтобы понять, принадлежит ли какое-то значение списку, нам нужно пройти по всему списку и сравнивать каждое из значений с необходимым. Если список большой, это может занимать какое-то время.

Если список состоит из чисел, то мы можем отсортировать его и находить числа значительно быстрее (см. алгоритм бинарного поиска, он очень простой). Однако поиск по словарю все равно быстрее и не зависит от размера словаря. Поиск по словарю, в котором миллион значений, будет занимать столько же времени, сколько и поиск по словарю размера 1. Такая скорость достигается благодаря хэш-таблицам, на основе которых построены словари. Мы не будем подробно на этом останавливаться, но можете почитать про это на досуге.

Как итерироваться по словарю? Очень просто - нужно использовать функцию `items`:

```python
for country, capital in capital_by_country.items():
    print(country, capital)
```

Обратите внимание, что порядок может не совпадать с тем, в каком порядке вы задавали элементы словаря выше. Элементы словаря хранятся в произовольном порядке.

Также обычно про словарь говорят как про структуру, которая хранит пары ключ-значение. В нашем случае ключами были строки - названия стран, а значениями также были строки - названия столиц. Ключами могут быть и другие типы данных - числа и кортежи (но не списки и словари), а вот значениями могут быть любые типы данных.

## Множество

Множество - компромисс между словарем и списком. Позволяет хранить в себе неповторяющиеся объекты. Добавление, поиск и удаление объектов происходит очень быстро, но порядок элементов не гарантируется. Также множества можно пересекать, объединять и вычитать:

```python
s = {1, 2, 3}
s.add(1) # ничего не произойдет, 1 уже в множестве
s.add(4) # добавится 4

s.remove(1) # убираем 1

s2 = {2, 3}
s2.intersect(s) # {2, 3}

s.union(s2) # {2, 3, 4}
s.difference(s2) # 4
```
