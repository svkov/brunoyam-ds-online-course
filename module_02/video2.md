# Видео 2

Вы немного попрактиковались в решении задач и начали свой путь в программировании. Давайте теперь обсудим чем язык python отличается от других языков и где его следует использовать с осторожностью.

Python - очень медленный язык. Это связано с большим количеством факторов и нам остается только смириться с этим. Он медленнее С++ на порядки, на некоторых тестах разность в скорости может отличаться в сотни раз. Но это не мешает нам быстро решать задачи, которые не требуют большой производительности. Например, писать сложные трехмерные игры на питоне не стоит, а вот для веб-сервиса, которым будет пользоваться несколько десятков тысяч человек в день, пайтон подойдет идеально. Нам как аналитикам не так важна скорость выполнения кода. Большинство библиотек, которые мы будем использовать, были написаны умными людьми, которые оптимизровали там все, что могли и сделали это на быстрых языках. Если же мы столкнемся именно с ограничениями в скорости питона, то это не беда, мы сможем подождать. Код, который пишут аналитики, обычно не так требователен с скорости работы, потому что пользователи напрямую не работают с нашим кодом.

Еще одной отличительной чертой Python является его интерпретируемость. Языки программирования делятся на компилируемые и интерпретируемые. Разница состоит в том, что для компилируемых языков существует специальная программа - компилятор - которая превращает код в исполняемый файл. Например, если вы написали программу на С++, а затем ее скомпилировали, то вы бы получили exe-файл. На этапе компиляции код упрощается и оптимизируется, а также приводится в формат, понятный компьютеру. Благодаря компиляции код исполняется быстрее и большинство ошибок компилятор умеет находить, но мы ограничены тем, что заранее заложили в программу. Если мы захотим как-то изменить поведение программы, нам придется заново компилировать весь проект, а в случае с большим проектом это может быть очень долго.
В интерпретируемых языках все наоборот - код читается при помощи программы-интерпретатора прямо из файла, где вы его написали и тут же исполняется, не создавая никаких промежуточных файлов. У нас нет дополнительного шага, который бы проверял код на корректность, поэтому часто встречается ситуация, что код падает в самый неподходящий момент, и мы теряем в скорости. Но зато у нас развязываются руки на довольно интересное поведение кода. Напимер, мы можем прямо из кода генерировать другой код и запускать его в рамках этой же программы. Программа может узнать любую информацию о самой себе - в каком файле она сейчас находится, какой тип у каждой переменной и многое другое.
Нельзя однозначно сказать, что лучше - компилируемые или интерпретируемые языки, они просто по-разному справляются с разными задачами. Инструмент нужно выбирать под те задачи, которые вы собираетесь решать.

Еще одной отличительной чертой питона является то, что у него динамическая, но при этом строгая типизация. Вы уже могли заметить, что на протяжении исполнения программы тип переменной может поменяться. Мы можем ловко жонглировать типами, перегоняя строки в числа и обратно. Это и называется динамической типизацией. Интерпретатор заранее не может сказать какого типа будет переменная в момент исполнения. В языках со статической типизацией если вы объявили, что какая-то переменная будет числом, то она всегда будет числом, и если вы попытаетесь сложить ее со строкой, то получите ошибку еще на этапе компиляции. В питоне же типизация хоть и динамическая, но все же строгая. То есть, если вы попытаетесь сложить число со строкой, то у вас появится ошибка, но ровно в тот момент, когда интерпретатор попытается сложить эти две переменные. Если бы типизация была нестрогой, то число бы автоматически превратилось в строку (так, например, происходит в javascript), но этого не происходит.

На практике важно всегда помнить какого типа каждая из ваших переменных в нужном кусочке кода и какие операции с ней можно совершать. Особенно это полезно, когда разбираетесь с чужим кодом и пытаетесь его модифицировать.

Мы познакомились с базовыми концепциями программирования на python и готовы двигаться дальше. В следующем модуле поговорим про коллекции и то, как с ними работать.
