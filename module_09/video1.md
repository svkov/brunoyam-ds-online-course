# Видео по доверительным интервалам

Доверительные интервалы позволяют оценивать параметры случайной величины в каком-то диапазоне. Посчитав среднее значение, мы можем точечно оценить матожидание случайной величины, но посчитав 95%-ый доверительный интервал мы определим в каком диапазоне случайная величина реализуется с вероятностью 0.95. Помимо оценок самой величины мы можем оценивать матожидание случайной величины.

Давайте посмотрим как это сделать.

Будем анализировать нормально распределенную случайную величину с матожиданием 100 и среднеквадратичным отклонением 10. Мы хотим узнать в каких диапазонах с вероятностью 95% будет следующее значение, которое мы сгененрируем из этой случайной величины. Давайте оценим его при помощи функции `interval` из `scipy`:

```python
alpha = 0.95
loc = 100
std = 10

stats.norm.interval(alpha, loc=loc, scale=std)
```

Как видим, разброс довольно большой, но в целом адекватный.

А теперь давайте оценим в каких диапазонах будет находиться среднее значение выборки размера 30, сгенерированной из этой случайной величины. Для этого нужно разделить среднеквадратичное отклонение на корень из n.

```python
n = 30

stats.norm.interval(alpha, loc=loc, scale=std / np.sqrt(n))
```

Эта оценка гораздо более точная, однако если установить n меньше, то и оценка станет менее точной.

Теперь давайте сгенерируем выборку из этого распределения, оценим для нее параметры и определим доверительный интервал для матожидания.

В данном случае настоящая дисперсия нам неизвестна, поэтому мы должны использовать распределение Стьюдента, а не нормальное, для оценки. Как видим, настоящее матожидание содержится внутри нашего интервала, но так может быть не всегда. Так как доверительный интервал 95%-ый, то мы можем лишь с вероятностью 95% оценить, в каком интервале лежит настоящее матожидание. Соответственно, вероятность нашей ошибки 5%.

Давайте проверим это. Сгенерируем 1000 выборок и проверим, в скольки из них мы правильно оценили интервал.

```python
error = 0
for i in range(1000):
    sample = np.random.normal(loc=loc, scale=std, size=n)
    a, b = stats.t.interval(alpha, n - 1, loc=sample.mean(), scale=sample.std() / np.sqrt(n))
    if a > loc or b < loc:
        error += 1
error
```

Как раз около 5%.
